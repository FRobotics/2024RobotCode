
VI		Notes

- ClimbBegin
		X Suggest setting the smart current limit to TRUE.  Currently this is an unwired input to this VI.
			It defaults to FALSE.
		X I didn't look, but ensure that there are current limits.  Ask build and electrical to
			tell us what the current limits should be.
		X ensure sensor scaling factor is set.
		

- ClimbExec
		X Climb is not rotational like the arm.  Do NOT use COSINE to compensate for the weight being lifted.
		If the motor is pulling down (output is negative), leave alone.  If output is pushing up (output is
		positive) multiply the output by a constant fractional number -- say 0.3.  
		X do you want separate demands for left and right ??  You could use one demand for both.
		X create a virtual forward limit switch.  This would be true if height is >= some constant.
		X When hitting the bottom limit switch, suggest setting the position to 0.  Suggest that 
			to ensure that there isn't a strange bounce process the raw limit switch value with
			"on delay" then to an "edge on" then to the case statement that sets the position to
			zero. 
		X It would be best to use the same set of tuning constants for left and right (this helps to ensure
			that somehow the constants aren't different, resulting in different motor actions.


- BoxBegin
		X probably don't need current limits for either shooter or intake.  Suggest removing
		X The sensor type for the built in is "hall..." not encoder.  (Encoder 
			is for an externally attached encoder.
		X suggest setting rate limit for shooter.  maybe 0.1 seconds to full speed.
			this will limit the current draw and help battery
		X suggest setting rate limit for intake.  maybe 0.1 seconds to full speed.
			this will limit the current draw and help battery
		X for intake the current gear ratio is 36:1.  Suggest setting the sensor scaling 1/36
			so we can measure RPM of the intake wheels.  If you want the units to be
			rev/seconds then multiply by 1/60....


- BoxExec
		X suggest writing filtered speed to network table variables.
		X check the permissive for issuing the shooting command - Do you want state = Have Note?
		X "used note" - do you want the sensor detection to be on or off (I'm thinking off).  Also
			you might want to add an Off Delay here.  The intake sensor is pretty far from
			the intake and the speed is slower.
		X start shoot - should shoot wheel setpoint be zero?  It is really okay since the next
			state sets the speed demand.
		X the "Set" functions are really "Get" functions.  They are getting the global variable values
			for others to use.  Suggest renaming.
		X for commands, suggest using "bool cmd mux array"  under General digital -> bool cmd.
			this helps arbitrate among commands.  Could just use individual bool cmd and process
			in state machine.  (works the same.)
		X dont need to feed time to the write network table variables..
		# Just a note -- after invert of digital inputs, sensors mean
				intake	shooter
				-----	------
				False	False	No note
				False	True	Have note (note in shooter wheels)
				True	False	Have note (ready to shoot)
				True	True	Have note (mis-aligned)


- ArmBegin2	
		X Set the starting angle
		X Set the primary current limit to 40 Amps
		X  Suggest naming this Arm2Begin 
		X  The NEO is a "brushless" motor.
		X  Use "set limit switch config" for "forward" switch.  
		   	X Set to enabled to TRUE.
		   	X Set polarity to normally open.
		X  Use "set limit switch config" for "reverse" switch.  
		   	X Set to enabled to TRUE.
		   	X Set polarity to normally open.
		X  Use "Set Ramp Rate".  Suggest 0 to full speed in 0.2 seconds.
		X  Use "Set sensor conversion".  For postion if 1 = Revloutions, 
			use Deg/Revolutions and 1/GearRatio to calculate new
			conversion factor.   Same thing for velocity.  Standard units 
			are Revolution / Minute.  We know 1 Minute / 60 seconds 
			and Deg/Revolutions and 1/GearRatio.
		X set a value for initial position.  Put a note that this needs to be
			set.


- Arm2Exec
		X when hitting the reverse limit switch set the actual angle.  Right now it is zero.
		X when hitting the upper limit switch, add code to set the sensor angle.  Right now it it zero.
		X When hitting the top limit switch, suggest setting the position to top value.  Suggest that 
			to ensure that there isn't a strange bounce process the raw limit switch value with
			"on delay" then to an "edge on" then to the case statement that sets the position to
			top value. 
		n/a When hitting the bottom limit switch, suggest setting the position to bottom value.  Suggest that 
			to ensure that there isn't a strange bounce process the raw limit switch value with
			"on delay" then to an "edge on" then to the case statement that sets the position to
			bottom value. 
		X set "first time" setpoint equal to position so it doesnt move.
		X feed this setpoint and the position that is read from motor controller to the position control.
		- write the result to the motor.
		X the position control has inputs for the limit switches too.
		X dont need to feed time to the write network table variables..  Okayyyyyy
  		X Suggest renaming this to Arm2Execute...
		X This will be position control.  The math library now has a position
			control routine.
		X Read the sensors first ( position, velocity, forward and reverse limit switches )
		X write these to network tables.
		X use position control to set motor output.  We can discuss tuning.


- Human Execute
		- Determine what driving modes are needed.  For example:
			0 - Normal Swerve Drive
			1 - Go to amp
			2 - Go to speaker
			3 - Go to source
			4.... - whatever ......
		- create code to determine the mode number
		- modify the drive "human action cache" (suggest renaming) to do
			driving for each mode.

		- add code for 2nd controller

		- add code for 3rd controller (button box)

		- add climb commands

		- add arm commands

		- add box commmands

		- suggest removing the drive modifier -- it doesn't do anything anyway.
			if you want a slow mode add code for that.  suggest using a
			set-reset flip flop to store the value. Write value to network
			tables.  Add the value as an input to "human action cache"
			and multiply the mode 0 with the slow mode factor as appropriate.
			(Suggest not using this to modify other modes...)





